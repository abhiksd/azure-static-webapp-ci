name: Enhanced CI/CD Pipeline

on:
  push:
    branches: [main, develop, staging, preprod]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'development'
        type: choice
        options:
        - development
        - staging
        - pre-production
        - production
      force_deploy:
        description: 'Force deployment even if checks fail'
        type: boolean
        default: false
      enable_monitoring:
        description: 'Enable enhanced monitoring'
        type: boolean
        default: true
      enable_sonar:
        description: 'Enable SonarCloud analysis'
        type: boolean
        default: true
      enable_checkmarx:
        description: 'Enable Checkmarx security scanning'
        type: boolean
        default: false
      force_version:
        description: 'Override semantic version (production only)'
        required: false
        type: string
      skip_semantic_release:
        description: 'Skip semantic versioning and use pre-release format'
        type: boolean
        default: false

# Grant GITHUB_TOKEN the permissions required to interact with OIDC
permissions:
  id-token: write   # This is required for requesting the JWT
  contents: read    # This is required for actions/checkout
  security-events: write # This is required for github/codeql-action/upload-sarif
  pull-requests: write # This is required for PR comments
  checks: write     # This is required for check runs
  deployments: write # This is required for deployment status

env:
  NODE_VERSION: '18'
  
  # Security scanning configuration - use workflow inputs if available, otherwise use repository variables
  ENABLE_SONAR: ${{ github.event.inputs.enable_sonar || vars.ENABLE_SONAR_SCAN || 'true' }}
  ENABLE_CHECKMARX: ${{ github.event.inputs.enable_checkmarx || vars.ENABLE_CHECKMARX_SCAN || 'false' }}

  # Static Web Apps tokens (these remain as secrets)
  AZURE_STATIC_WEB_APPS_API_TOKEN_DEV: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_DEV }}
  AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}
  AZURE_STATIC_WEB_APPS_API_TOKEN_PROD: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}

jobs:
  # Detect changes and determine deployment strategy
  detect-changes:
    name: üîç Detect Changes
    runs-on: ubuntu-latest
    outputs:
      should-deploy-dev: ${{ steps.changes.outputs.should-deploy-dev }}
      should-deploy-staging: ${{ steps.changes.outputs.should-deploy-staging }}
      should-deploy-prod: ${{ steps.changes.outputs.should-deploy-prod }}
      version: ${{ steps.version.outputs.new-version }}
      dev-version: ${{ steps.version.outputs.dev-version }}
      staging-version: ${{ steps.version.outputs.staging-version }}
      semantic-version: ${{ steps.version.outputs.semantic-version }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Detect deployment targets
        id: changes
        run: |
          # Determine deployment targets based on branch, tags, and release events
          BRANCH="${{ github.ref_name }}"
          REF_TYPE="${{ github.ref_type }}"
          EVENT_NAME="${{ github.event_name }}"
          
          echo "üîç Deployment Detection:"
          echo "  Branch: $BRANCH"
          echo "  Ref Type: $REF_TYPE"
          echo "  Event: $EVENT_NAME"
          
          # Initialize all deployment flags to false
          DEPLOY_DEV=false
          DEPLOY_STAGING=false
          DEPLOY_PREPROD=false
          DEPLOY_PROD=false
          
          # Check for semantic version tags (production releases)
          if [[ "$REF_TYPE" == "tag" ]] && [[ "$BRANCH" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "üè∑Ô∏è Production release tag detected: $BRANCH"
            DEPLOY_PROD=true
            
          # Check for pre-release tags (pre-production)
          elif [[ "$REF_TYPE" == "tag" ]] && [[ "$BRANCH" =~ ^v[0-9]+\.[0-9]+\.[0-9]+-pre\. ]]; then
            echo "üè∑Ô∏è Pre-release tag detected: $BRANCH"
            DEPLOY_PREPROD=true
            
          # Check for release candidate tags
          elif [[ "$REF_TYPE" == "tag" ]] && [[ "$BRANCH" =~ ^v[0-9]+\.[0-9]+\.[0-9]+-rc\. ]]; then
            echo "üè∑Ô∏è Release candidate tag detected: $BRANCH"
            DEPLOY_PREPROD=true
            
          # Branch-based deployments
          elif [[ "$REF_TYPE" == "branch" ]]; then
            case "$BRANCH" in
              "main")
                echo "üåü Main branch: Deploy to dev and staging (production requires tags)"
                DEPLOY_DEV=true
                DEPLOY_STAGING=true
                ;;
              "develop")
                echo "üîß Develop branch: Deploy to dev only"
                DEPLOY_DEV=true
                ;;
              "staging")
                echo "üß™ Staging branch: Deploy to staging only"
                DEPLOY_STAGING=true
                ;;
              "preprod"|"preproduction")
                echo "üéØ Pre-production branch: Deploy to pre-prod"
                DEPLOY_PREPROD=true
                ;;
              release/*)
                echo "üöÄ Release branch: Deploy to pre-prod and staging"
                DEPLOY_STAGING=true
                DEPLOY_PREPROD=true
                ;;
              hotfix/*)
                echo "üî• Hotfix branch: Deploy to dev and staging"
                DEPLOY_DEV=true
                DEPLOY_STAGING=true
                ;;
              feature/*)
                echo "‚ú® Feature branch: Deploy to dev only"
                DEPLOY_DEV=true
                ;;
              *)
                echo "üîç Other branch: No automatic deployment"
                ;;
            esac
          fi
          
          # Handle workflow dispatch manual overrides
          if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            TARGET_ENV="${{ github.event.inputs.environment }}"
            echo "üéõÔ∏è Manual deployment to: $TARGET_ENV"
            
            case "$TARGET_ENV" in
              "development")
                DEPLOY_DEV=true
                DEPLOY_STAGING=false
                DEPLOY_PREPROD=false
                DEPLOY_PROD=false
                ;;
              "staging")
                DEPLOY_DEV=false
                DEPLOY_STAGING=true
                DEPLOY_PREPROD=false
                DEPLOY_PROD=false
                ;;
              "pre-production")
                DEPLOY_DEV=false
                DEPLOY_STAGING=false
                DEPLOY_PREPROD=true
                DEPLOY_PROD=false
                ;;
              "production")
                DEPLOY_DEV=false
                DEPLOY_STAGING=false
                DEPLOY_PREPROD=false
                DEPLOY_PROD=true
                ;;
            esac
          fi
          
          # Output deployment decisions
          echo "should-deploy-dev=$DEPLOY_DEV" >> $GITHUB_OUTPUT
          echo "should-deploy-staging=$DEPLOY_STAGING" >> $GITHUB_OUTPUT
          echo "should-deploy-preprod=$DEPLOY_PREPROD" >> $GITHUB_OUTPUT
          echo "should-deploy-prod=$DEPLOY_PROD" >> $GITHUB_OUTPUT
          
          echo ""
          echo "üìã Deployment Plan:"
          echo "  Development: $DEPLOY_DEV"
          echo "  Staging: $DEPLOY_STAGING"
          echo "  Pre-Production: $DEPLOY_PREPROD"
          echo "  Production: $DEPLOY_PROD"
          
      - name: Generate Environment-Specific Versions
        id: version
        run: |
          # Generate short SHA for dev/staging environments
          SHORT_SHA=$(echo ${{ github.sha }} | head -c 7)
          TIMESTAMP=$(date +%Y%m%d-%H%M)
          
          # For development and staging: use short SHA tags
          DEV_VERSION="dev-${SHORT_SHA}-${TIMESTAMP}"
          STAGING_VERSION="staging-${SHORT_SHA}-${TIMESTAMP}"
          
          echo "dev-version=$DEV_VERSION" >> $GITHUB_OUTPUT
          echo "staging-version=$STAGING_VERSION" >> $GITHUB_OUTPUT
          
          # For pre-prod and production: use semantic versioning
          # Check for manual version override first
          SEMANTIC_VERSION=""
          if [ "${{ github.event.inputs.force_version }}" != "" ]; then
            SEMANTIC_VERSION="${{ github.event.inputs.force_version }}"
            echo "Using manual version override: $SEMANTIC_VERSION"
          elif [ "${{ github.event.inputs.skip_semantic_release }}" = "true" ]; then
            # Force pre-release format
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            if [[ "$LAST_TAG" =~ ^v?([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
              MAJOR=${BASH_REMATCH[1]}
              MINOR=${BASH_REMATCH[2]}
              PATCH=${BASH_REMATCH[3]}
              PATCH=$((PATCH + 1))
              SEMANTIC_VERSION="v${MAJOR}.${MINOR}.${PATCH}-pre.${SHORT_SHA}"
            else
              SEMANTIC_VERSION="v1.0.0-pre.${SHORT_SHA}"
            fi
            echo "Skipping semantic release, using pre-release: $SEMANTIC_VERSION"
          elif git describe --exact-match --tags HEAD 2>/dev/null; then
            SEMANTIC_VERSION=$(git describe --exact-match --tags HEAD)
            echo "Found semantic version tag: $SEMANTIC_VERSION"
          else
            # Generate semantic version based on previous tags
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            if [[ "$LAST_TAG" =~ ^v?([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
              MAJOR=${BASH_REMATCH[1]}
              MINOR=${BASH_REMATCH[2]}
              PATCH=${BASH_REMATCH[3]}
              # Auto-increment patch for pre-releases
              PATCH=$((PATCH + 1))
              SEMANTIC_VERSION="v${MAJOR}.${MINOR}.${PATCH}-pre.${SHORT_SHA}"
            else
              SEMANTIC_VERSION="v1.0.0-pre.${SHORT_SHA}"
            fi
            echo "Generated semantic version: $SEMANTIC_VERSION"
          fi
          
          echo "semantic-version=$SEMANTIC_VERSION" >> $GITHUB_OUTPUT
          
          # Legacy compatibility - use semantic version as primary
          echo "new-version=$SEMANTIC_VERSION" >> $GITHUB_OUTPUT
          
          echo "üè∑Ô∏è Version Summary:"
          echo "  Development: $DEV_VERSION"
          echo "  Staging: $STAGING_VERSION"
          echo "  Pre-Production/Production: $SEMANTIC_VERSION"

  # Quality checks and security scanning
  quality-checks:
    name: üîç Quality & Security Checks
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Run quality checks
        run: |
          echo "üîç Running quality checks..."
          npm run lint
          npm run test:coverage
          npm run build
          
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        if: env.ENABLE_SONAR == 'true' && secrets.SONAR_TOKEN != '' && (github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Checkmarx Security Scan
        if: env.ENABLE_CHECKMARX == 'true' && secrets.CHECKMARX_CLIENT != ''
        uses: checkmarx-ts/checkmarx-cxflow-github-action@v1.6
        with:
          project: ${{ github.repository }}
          team: /CxServer/SP/Company
          checkmarx_url: ${{ secrets.CHECKMARX_SERVER || 'https://checkmarx.company.com' }}
          checkmarx_client: ${{ secrets.CHECKMARX_CLIENT }}
          checkmarx_secret: ${{ secrets.CHECKMARX_SECRET }}
          scanners: ${{ vars.CHECKMARX_SCAN_TYPES || 'sca,sast,kics' }}
          params: |
            --bug-tracker=GITHUBPULL
            --preset="${{ vars.CHECKMARX_PRESET || 'Checkmarx Default' }}"
            --incremental=${{ vars.CHECKMARX_INCREMENTAL || 'true' }}
            --exclude-folders="${{ vars.CHECKMARX_EXCLUDE_FOLDERS || 'node_modules,dist,build,coverage' }}"
            --exclude-files="${{ vars.CHECKMARX_EXCLUDE_FILES || '*.min.js,*.bundle.js' }}"
            --cx-flow.filter-severity=High,Medium,Low
            --severity-threshold=High
            --sca-resolver=npm,gradle,maven
            --kics-timeout=600

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/lcov.info
          fail_ci_if_error: false

  # Deploy to Development Environment
  deploy-development:
    name: üöÄ Deploy to Development
    runs-on: ubuntu-latest
    needs: [detect-changes, quality-checks]
    if: needs.detect-changes.outputs.should-deploy-dev == 'true'
    environment: 
      name: development
      url: https://dev.yourdomain.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Get Azure Key Vault secrets
        uses: ./.github/actions/azure-keyvault
        with:
          keyvault-name: ${{ vars.AZURE_KEYVAULT_NAME_DEV }}
          use-managed-identity: 'true'

      - name: Enhanced Deployment
        id: deploy
        uses: ./.github/actions/enhanced-deploy
        with:
          azure-static-web-apps-api-token: ${{ env.AZURE_STATIC_WEB_APPS_API_TOKEN_DEV }}
          environment: development
          version: ${{ needs.detect-changes.outputs.dev-version }}
          enable-health-checks: 'true'
          enable-monitoring: 'true'
          enable-rollback: 'true'
          monitoring-duration: '5'
          slack-webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          teams-webhook-url: ${{ secrets.TEAMS_WEBHOOK_URL }}

      - name: Update Environment Status
        if: always()
        run: |
          STATUS="${{ steps.deploy.outputs.health-check-status }}"
          echo "Development deployment status: $STATUS"
          
          # Update GitHub deployment status
          if [ "$STATUS" = "healthy" ]; then
            echo "üéØ Development environment is healthy"
          else
            echo "‚ö†Ô∏è Development environment needs attention"
          fi

  # Deploy to Staging Environment
  deploy-staging:
    name: üöÄ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [detect-changes, quality-checks, deploy-development]
    if: needs.detect-changes.outputs.should-deploy-staging == 'true' && (success() || needs.deploy-development.result == 'skipped')
    environment: 
      name: staging
      url: https://staging.yourdomain.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Get Azure Key Vault secrets
        uses: ./.github/actions/azure-keyvault
        with:
          keyvault-name: ${{ vars.AZURE_KEYVAULT_NAME_STAGING }}
          use-managed-identity: 'true'

      - name: Enhanced Deployment
        id: deploy
        uses: ./.github/actions/enhanced-deploy
        with:
          azure-static-web-apps-api-token: ${{ env.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}
          environment: staging
          version: ${{ needs.detect-changes.outputs.staging-version }}
          enable-health-checks: 'true'
          enable-monitoring: 'true'
          enable-rollback: 'true'
          monitoring-duration: '10'
          slack-webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          teams-webhook-url: ${{ secrets.TEAMS_WEBHOOK_URL }}

      - name: Run Integration Tests
        run: |
          echo "üß™ Running integration tests against staging..."
          # Add your integration test commands here
          npm run test:integration || echo "Integration tests not configured"

      - name: Performance Testing
        run: |
          echo "‚ö° Running performance tests..."
          # Add Lighthouse or other performance testing
          npx lighthouse https://staging.yourdomain.com --output=json --output-path=lighthouse-staging.json --chrome-flags="--headless --no-sandbox" || echo "Performance tests not configured"

  # Deploy to Pre-Production Environment
  deploy-preprod:
    name: üöÄ Deploy to Pre-Production
    runs-on: ubuntu-latest
    needs: [detect-changes, quality-checks, deploy-staging]
    if: needs.detect-changes.outputs.should-deploy-prod == 'true' && (success() || needs.deploy-staging.result == 'skipped')
    environment: 
      name: pre-production
      url: https://preprod.yourdomain.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Get Azure Key Vault secrets
        uses: ./.github/actions/azure-keyvault
        with:
          keyvault-name: ${{ vars.AZURE_KEYVAULT_NAME_PROD }}
          use-managed-identity: 'true'

      - name: Enhanced Deployment
        id: deploy
        uses: ./.github/actions/enhanced-deploy
        with:
          azure-static-web-apps-api-token: ${{ env.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}
          environment: pre-production
          version: ${{ needs.detect-changes.outputs.semantic-version }}
          enable-health-checks: 'true'
          enable-monitoring: 'true'
          enable-rollback: 'true'
          monitoring-duration: '15'
          slack-webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          teams-webhook-url: ${{ secrets.TEAMS_WEBHOOK_URL }}

      - name: Security Testing
        run: |
          echo "üîí Running security tests..."
          # Add security testing commands
          echo "Security tests completed"

      - name: Load Testing
        run: |
          echo "üìä Running load tests..."
          # Add load testing commands
          echo "Load tests completed"

  # Deploy to Production Environment (requires manual approval)
  deploy-production:
    name: üöÄ Deploy to Production
    runs-on: ubuntu-latest
    needs: [detect-changes, quality-checks, deploy-preprod]
    if: needs.detect-changes.outputs.should-deploy-prod == 'true' && success()
    environment: 
      name: production
      url: https://yourdomain.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Get Azure Key Vault secrets
        uses: ./.github/actions/azure-keyvault
        with:
          keyvault-name: ${{ vars.AZURE_KEYVAULT_NAME_PROD }}
          use-managed-identity: 'true'

      - name: Enhanced Deployment
        id: deploy
        uses: ./.github/actions/enhanced-deploy
        with:
          azure-static-web-apps-api-token: ${{ env.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}
          environment: production
          version: ${{ needs.detect-changes.outputs.semantic-version }}
          enable-health-checks: 'true'
          enable-monitoring: 'true'
          enable-rollback: 'true'
          monitoring-duration: '30'
          slack-webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          teams-webhook-url: ${{ secrets.TEAMS_WEBHOOK_URL }}

      - name: Post-deployment Validation
        run: |
          echo "‚úÖ Running post-deployment validation..."
          # Add post-deployment validation commands
          curl -f https://yourdomain.com/api/health || echo "Health check failed"

      - name: Create GitHub Release
        if: success()
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.detect-changes.outputs.semantic-version }}
          release_name: Release ${{ needs.detect-changes.outputs.semantic-version }}
          body: |
            üöÄ Production deployment successful
            
            **Version:** ${{ needs.detect-changes.outputs.semantic-version }}
            **Commit:** ${{ github.sha }}
            **Environment:** Production
            
            **Changes:**
            ${{ github.event.head_commit.message }}
          draft: false
          prerelease: false

  # Cleanup and Notifications
  post-deployment:
    name: üìä Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always()
    
    steps:
      - name: Deployment Summary
        run: |
          echo "üìä Deployment Summary"
          echo "===================="
          echo "üè∑Ô∏è Version Tags:"
          echo "  Development: ${{ needs.detect-changes.outputs.dev-version }}"
          echo "  Staging: ${{ needs.detect-changes.outputs.staging-version }}"
          echo "  Pre-Production/Production: ${{ needs.detect-changes.outputs.semantic-version }}"
          echo ""
          echo "üöÄ Deployment Results:"
          echo "  Development: ${{ needs.deploy-development.result }}"
          echo "  Staging: ${{ needs.deploy-staging.result }}"
          echo "  Pre-Production: ${{ needs.deploy-preprod.result }}"
          echo "Production: ${{ needs.deploy-production.result }}"

