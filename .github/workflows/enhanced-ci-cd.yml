name: Enhanced CI/CD Pipeline

on:
  push:
    branches: [main, develop, staging, preprod]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'development'
        type: choice
        options:
        - development
        - staging
        - pre-production
        - production
      force_deploy:
        description: 'Force deployment even if checks fail'
        type: boolean
        default: false
      enable_monitoring:
        description: 'Enable enhanced monitoring'
        type: boolean
        default: true
      enable_sonar:
        description: 'Enable SonarCloud analysis'
        type: boolean
        default: true
      enable_checkmarx:
        description: 'Enable Checkmarx security scanning'
        type: boolean
        default: false
      force_version:
        description: 'Override semantic version (production only)'
        required: false
        type: string
      skip_semantic_release:
        description: 'Skip semantic versioning and use pre-release format'
        type: boolean
        default: false

# Grant GITHUB_TOKEN the permissions required to interact with OIDC
permissions:
  id-token: write   # This is required for requesting the JWT
  contents: read    # This is required for actions/checkout
  security-events: write # This is required for github/codeql-action/upload-sarif
  pull-requests: write # This is required for PR comments
  checks: write     # This is required for check runs
  deployments: write # This is required for deployment status

env:
  NODE_VERSION: '18'
  
  # Security scanning configuration - use workflow inputs if available, otherwise use repository variables
  ENABLE_SONAR: ${{ github.event.inputs.enable_sonar || vars.ENABLE_SONAR_SCAN || 'true' }}
  ENABLE_CHECKMARX: ${{ github.event.inputs.enable_checkmarx || vars.ENABLE_CHECKMARX_SCAN || 'false' }}

  # Static Web Apps tokens (these remain as secrets)
  AZURE_STATIC_WEB_APPS_API_TOKEN_DEV: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_DEV }}
  AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}
  AZURE_STATIC_WEB_APPS_API_TOKEN_PROD: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}

jobs:
  # Detect changes and determine deployment strategy
  detect-changes:
    name: üîç Detect Changes
    runs-on: ubuntu-latest
    outputs:
      should-deploy-dev: ${{ steps.changes.outputs.should-deploy-dev }}
      should-deploy-staging: ${{ steps.changes.outputs.should-deploy-staging }}
      should-deploy-preprod: ${{ steps.changes.outputs.should-deploy-preprod }}
      should-deploy-prod: ${{ steps.changes.outputs.should-deploy-prod }}
      # Environment-specific versions
      dev-version: ${{ steps.version.outputs.dev-version }}
      staging-version: ${{ steps.version.outputs.staging-version }}
      semantic-version: ${{ steps.version.outputs.semantic-version }}
      # Legacy compatibility
      version: ${{ steps.version.outputs.semantic-version }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Detect deployment targets
        id: changes
        run: |
          # Determine deployment targets based on branch, tags, and release events
          BRANCH="${{ github.ref_name }}"
          REF_TYPE="${{ github.ref_type }}"
          EVENT_NAME="${{ github.event_name }}"
          
          echo "üîç Deployment Detection:"
          echo "  Branch: $BRANCH"
          echo "  Ref Type: $REF_TYPE"
          echo "  Event: $EVENT_NAME"
          
          # Initialize all deployment flags to false
          DEPLOY_DEV=false
          DEPLOY_STAGING=false
          DEPLOY_PREPROD=false
          DEPLOY_PROD=false
          
          # Production-Grade Tag-Based Deployments
          
          # PRODUCTION: Only semantic version tags (v1.2.3) with strict validation
          if [[ "$REF_TYPE" == "tag" ]] && [[ "$BRANCH" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "üè∑Ô∏è PRODUCTION release tag detected: $BRANCH"
            
            # Production-grade validations
            MAJOR=$(echo "$BRANCH" | sed -E 's/^v([0-9]+)\.([0-9]+)\.([0-9]+)$/\1/')
            MINOR=$(echo "$BRANCH" | sed -E 's/^v([0-9]+)\.([0-9]+)\.([0-9]+)$/\2/')
            PATCH=$(echo "$BRANCH" | sed -E 's/^v([0-9]+)\.([0-9]+)\.([0-9]+)$/\3/')
            
            echo "  Version breakdown: Major=$MAJOR, Minor=$MINOR, Patch=$PATCH"
            
            # Validate tag is properly signed (production requirement)
            if git verify-tag "$BRANCH" 2>/dev/null || [[ "${{ vars.SKIP_TAG_VERIFICATION }}" == "true" ]]; then
              echo "  ‚úÖ Tag verification passed"
              DEPLOY_PROD=true
            else
              echo "  ‚ùå WARNING: Tag not signed or verification failed"
              echo "  Production deployment requires signed tags unless SKIP_TAG_VERIFICATION=true"
              if [[ "${{ vars.ALLOW_UNSIGNED_PROD_TAGS }}" == "true" ]]; then
                echo "  üîì Proceeding with unsigned tag (ALLOW_UNSIGNED_PROD_TAGS=true)"
                DEPLOY_PROD=true
              fi
            fi
            
          # PRE-PRODUCTION: Pre-release and RC tags with validation
          elif [[ "$REF_TYPE" == "tag" ]] && [[ "$BRANCH" =~ ^v[0-9]+\.[0-9]+\.[0-9]+-(pre|rc|alpha|beta)\. ]]; then
            echo "üè∑Ô∏è PRE-PRODUCTION release tag detected: $BRANCH"
            
            # Extract pre-release type
            PRERELEASE_TYPE=$(echo "$BRANCH" | sed -E 's/^v[0-9]+\.[0-9]+\.[0-9]+-([^.]+)\..*$/\1/')
            echo "  Pre-release type: $PRERELEASE_TYPE"
            
            case "$PRERELEASE_TYPE" in
              "pre"|"rc")
                echo "  ‚úÖ Release candidate - deploying to pre-production"
                DEPLOY_PREPROD=true
                ;;
              "alpha"|"beta")
                echo "  üß™ Alpha/Beta release - deploying to staging and pre-production"
                DEPLOY_STAGING=true
                DEPLOY_PREPROD=true
                ;;
              *)
                echo "  üîç Unknown pre-release type - deploying to staging only"
                DEPLOY_STAGING=true
                ;;
            esac
            
          # Production-Grade Branch-Based Deployments
          elif [[ "$REF_TYPE" == "branch" ]]; then
            echo "üîÄ Branch-based deployment logic"
            
            case "$BRANCH" in
              "main"|"master")
                echo "üåü MAIN BRANCH (Production-ready code)"
                echo "  - Automatic: Development + Staging (CI/CD validation)"
                echo "  - Production: Requires manual release tag creation"
                
                # Main branch gets automatic dev/staging for integration testing
                DEPLOY_DEV=true
                DEPLOY_STAGING=true
                
                # Production requires explicit tagging (security best practice)
                echo "  üìã For production deployment:"
                echo "    1. Validate staging deployment"
                echo "    2. Create signed semantic version tag: git tag -s v1.2.3"
                echo "    3. Push tag: git push origin v1.2.3"
                ;;
                
              "develop"|"development")
                echo "üîß DEVELOP BRANCH (Active development)"
                echo "  - Purpose: Feature integration and testing"
                echo "  - Deployment: Development environment only"
                echo "  - Quality gates: Basic CI checks"
                
                DEPLOY_DEV=true
                ;;
                
              "staging")
                echo "üß™ STAGING BRANCH (Pre-production testing)"
                echo "  - Purpose: User acceptance testing and staging validation"
                echo "  - Deployment: Staging environment with full security scans"
                echo "  - Requirements: All quality gates must pass"
                
                # Staging branch requires enhanced security validation
                if [[ "${{ vars.STAGING_REQUIRES_APPROVAL }}" == "true" ]]; then
                  echo "  ‚ö†Ô∏è Staging deployment requires manual approval"
                  echo "    Set STAGING_AUTO_DEPLOY=true to enable automatic deployment"
                fi
                DEPLOY_STAGING=true
                ;;
                
              "preprod"|"preproduction"|"pre-production")
                echo "üéØ PRE-PRODUCTION BRANCH (Release preparation)"
                echo "  - Purpose: Final pre-production validation"
                echo "  - Deployment: Pre-production environment"
                echo "  - Security: Full security scans + penetration testing"
                echo "  - Performance: Load testing and monitoring"
                
                DEPLOY_PREPROD=true
                ;;
                
              release/*)
                echo "üöÄ RELEASE BRANCH (Release candidate)"
                RELEASE_VERSION=$(echo "$BRANCH" | sed 's/release\///')
                echo "  - Release version: $RELEASE_VERSION"
                echo "  - Purpose: Release stabilization and final testing"
                echo "  - Deployment: Staging + Pre-production"
                echo "  - Next step: Create RC tag when ready"
                
                # Release branches deploy to staging and pre-prod for validation
                DEPLOY_STAGING=true
                DEPLOY_PREPROD=true
                
                echo "  üìã Release process:"
                echo "    1. Deploy to staging for integration testing"
                echo "    2. Deploy to pre-prod for final validation"
                echo "    3. Create RC tag: git tag v${RELEASE_VERSION}-rc.1"
                echo "    4. After validation, create production tag: git tag v${RELEASE_VERSION}"
                ;;
                
              hotfix/*)
                echo "üî• HOTFIX BRANCH (Critical production fix)"
                HOTFIX_VERSION=$(echo "$BRANCH" | sed 's/hotfix\///')
                echo "  - Hotfix version: $HOTFIX_VERSION"
                echo "  - Purpose: Critical production issue resolution"
                echo "  - Deployment: Development + Staging (expedited)"
                echo "  - Fast-track: Can proceed to production with minimal validation"
                
                DEPLOY_DEV=true
                DEPLOY_STAGING=true
                
                # Hotfix can optionally deploy to pre-prod for critical fixes
                if [[ "${{ vars.HOTFIX_SKIP_PREPROD }}" != "true" ]]; then
                  echo "  - Also deploying to pre-production for validation"
                  DEPLOY_PREPROD=true
                fi
                
                echo "  ‚ö° Expedited process:"
                echo "    1. Deploy to dev/staging for validation"
                echo "    2. Create hotfix tag: git tag v${HOTFIX_VERSION}"
                echo "    3. Emergency production deployment available"
                ;;
                
              feature/*|feat/*)
                echo "‚ú® FEATURE BRANCH (New feature development)"
                FEATURE_NAME=$(echo "$BRANCH" | sed 's/feature\///' | sed 's/feat\///')
                echo "  - Feature: $FEATURE_NAME"
                echo "  - Purpose: Isolated feature development"
                echo "  - Deployment: Development environment only"
                echo "  - Testing: Unit tests + basic integration"
                
                DEPLOY_DEV=true
                ;;
                
              bugfix/*|fix/*)
                echo "üêõ BUGFIX BRANCH (Bug resolution)"
                BUG_NAME=$(echo "$BRANCH" | sed 's/bugfix\///' | sed 's/fix\///')
                echo "  - Bug fix: $BUG_NAME"
                echo "  - Purpose: Non-critical bug resolution"
                echo "  - Deployment: Development environment"
                
                DEPLOY_DEV=true
                ;;
                
              experimental/*|exp/*)
                echo "üî¨ EXPERIMENTAL BRANCH (Research and experiments)"
                echo "  - Purpose: Proof of concept and experimentation"
                echo "  - Deployment: Development environment (optional)"
                echo "  - Validation: Minimal requirements"
                
                # Experimental branches only deploy if explicitly enabled
                if [[ "${{ vars.DEPLOY_EXPERIMENTAL }}" == "true" ]]; then
                  DEPLOY_DEV=true
                  echo "  ‚úÖ Experimental deployment enabled"
                else
                  echo "  üö´ Experimental deployment disabled (set DEPLOY_EXPERIMENTAL=true to enable)"
                fi
                ;;
                
              *)
                echo "üîç UNKNOWN BRANCH TYPE"
                echo "  - Branch: $BRANCH"
                echo "  - Status: No automatic deployment configured"
                echo "  - Options: Use workflow dispatch for manual deployment"
                echo ""
                echo "  üìö Supported branch patterns:"
                echo "    - main/master: dev + staging"
                echo "    - develop: dev only"
                echo "    - staging: staging only"
                echo "    - release/*: staging + pre-prod"
                echo "    - hotfix/*: dev + staging (+ pre-prod)"
                echo "    - feature/*: dev only"
                echo "    - bugfix/*: dev only"
                ;;
            esac
          fi
          
          # Handle workflow dispatch manual overrides
          if [[ "$EVENT_NAME" == "workflow_dispatch" ]]; then
            TARGET_ENV="${{ github.event.inputs.environment }}"
            echo "üéõÔ∏è Manual deployment to: $TARGET_ENV"
            
            case "$TARGET_ENV" in
              "development")
                DEPLOY_DEV=true
                DEPLOY_STAGING=false
                DEPLOY_PREPROD=false
                DEPLOY_PROD=false
                ;;
              "staging")
                DEPLOY_DEV=false
                DEPLOY_STAGING=true
                DEPLOY_PREPROD=false
                DEPLOY_PROD=false
                ;;
              "pre-production")
                DEPLOY_DEV=false
                DEPLOY_STAGING=false
                DEPLOY_PREPROD=true
                DEPLOY_PROD=false
                ;;
              "production")
                DEPLOY_DEV=false
                DEPLOY_STAGING=false
                DEPLOY_PREPROD=false
                DEPLOY_PROD=true
                ;;
            esac
          fi
          
          # Output deployment decisions
          echo "should-deploy-dev=$DEPLOY_DEV" >> $GITHUB_OUTPUT
          echo "should-deploy-staging=$DEPLOY_STAGING" >> $GITHUB_OUTPUT
          echo "should-deploy-preprod=$DEPLOY_PREPROD" >> $GITHUB_OUTPUT
          echo "should-deploy-prod=$DEPLOY_PROD" >> $GITHUB_OUTPUT
          
          echo ""
          echo "üìã Deployment Plan:"
          echo "  Development: $DEPLOY_DEV"
          echo "  Staging: $DEPLOY_STAGING"
          echo "  Pre-Production: $DEPLOY_PREPROD"
          echo "  Production: $DEPLOY_PROD"
          
      - name: Generate Environment-Specific Versions
        id: version
        run: |
          # Generate short SHA for dev/staging environments
          SHORT_SHA=$(echo ${{ github.sha }} | head -c 7)
          TIMESTAMP=$(date +%Y%m%d-%H%M)
          
          # For development and staging: use short SHA tags
          DEV_VERSION="dev-${SHORT_SHA}-${TIMESTAMP}"
          STAGING_VERSION="staging-${SHORT_SHA}-${TIMESTAMP}"
          
          echo "dev-version=$DEV_VERSION" >> $GITHUB_OUTPUT
          echo "staging-version=$STAGING_VERSION" >> $GITHUB_OUTPUT
          
          # For pre-prod and production: use semantic versioning
          # Check for manual version override first
          SEMANTIC_VERSION=""
          if [ "${{ github.event.inputs.force_version }}" != "" ]; then
            SEMANTIC_VERSION="${{ github.event.inputs.force_version }}"
            echo "Using manual version override: $SEMANTIC_VERSION"
          elif [ "${{ github.event.inputs.skip_semantic_release }}" = "true" ]; then
            # Force pre-release format
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            if [[ "$LAST_TAG" =~ ^v?([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
              MAJOR=${BASH_REMATCH[1]}
              MINOR=${BASH_REMATCH[2]}
              PATCH=${BASH_REMATCH[3]}
              PATCH=$((PATCH + 1))
              SEMANTIC_VERSION="v${MAJOR}.${MINOR}.${PATCH}-pre.${SHORT_SHA}"
            else
              SEMANTIC_VERSION="v1.0.0-pre.${SHORT_SHA}"
            fi
            echo "Skipping semantic release, using pre-release: $SEMANTIC_VERSION"
          elif git describe --exact-match --tags HEAD 2>/dev/null; then
            SEMANTIC_VERSION=$(git describe --exact-match --tags HEAD)
            echo "Found semantic version tag: $SEMANTIC_VERSION"
          else
            # Generate semantic version based on previous tags
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            if [[ "$LAST_TAG" =~ ^v?([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
              MAJOR=${BASH_REMATCH[1]}
              MINOR=${BASH_REMATCH[2]}
              PATCH=${BASH_REMATCH[3]}
              # Auto-increment patch for pre-releases
              PATCH=$((PATCH + 1))
              SEMANTIC_VERSION="v${MAJOR}.${MINOR}.${PATCH}-pre.${SHORT_SHA}"
            else
              SEMANTIC_VERSION="v1.0.0-pre.${SHORT_SHA}"
            fi
            echo "Generated semantic version: $SEMANTIC_VERSION"
          fi
          
          echo "semantic-version=$SEMANTIC_VERSION" >> $GITHUB_OUTPUT
          
          # Legacy compatibility - use semantic version as primary
          echo "new-version=$SEMANTIC_VERSION" >> $GITHUB_OUTPUT
          
          echo "üè∑Ô∏è Version Summary:"
          echo "  Development: $DEV_VERSION"
          echo "  Staging: $STAGING_VERSION"
          echo "  Pre-Production/Production: $SEMANTIC_VERSION"

  # Quality checks and security scanning
  quality-checks:
    name: üîç Quality & Security Checks
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Run quality checks
        run: |
          echo "üîç Running quality checks..."
          npm run lint
          npm run test:coverage
          npm run build
          
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        if: env.ENABLE_SONAR == 'true' && secrets.SONAR_TOKEN != '' && (github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Checkmarx Security Scan
        if: env.ENABLE_CHECKMARX == 'true' && secrets.CHECKMARX_CLIENT != ''
        uses: checkmarx-ts/checkmarx-cxflow-github-action@v1.6
        with:
          project: ${{ github.repository }}
          team: /CxServer/SP/Company
          checkmarx_url: ${{ secrets.CHECKMARX_SERVER || 'https://checkmarx.company.com' }}
          checkmarx_client: ${{ secrets.CHECKMARX_CLIENT }}
          checkmarx_secret: ${{ secrets.CHECKMARX_SECRET }}
          scanners: ${{ vars.CHECKMARX_SCAN_TYPES || 'sca,sast,kics' }}
          params: |
            --bug-tracker=GITHUBPULL
            --preset="${{ vars.CHECKMARX_PRESET || 'Checkmarx Default' }}"
            --incremental=${{ vars.CHECKMARX_INCREMENTAL || 'true' }}
            --exclude-folders="${{ vars.CHECKMARX_EXCLUDE_FOLDERS || 'node_modules,dist,build,coverage' }}"
            --exclude-files="${{ vars.CHECKMARX_EXCLUDE_FILES || '*.min.js,*.bundle.js' }}"
            --cx-flow.filter-severity=High,Medium,Low
            --severity-threshold=High
            --sca-resolver=npm,gradle,maven
            --kics-timeout=600

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/lcov.info
          fail_ci_if_error: false

  # Deploy to Development Environment
  deploy-development:
    name: üöÄ Deploy to Development
    runs-on: ubuntu-latest
    needs: [detect-changes, quality-checks]
    if: needs.detect-changes.outputs.should-deploy-dev == 'true'
    environment: 
      name: development
      url: https://dev.yourdomain.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Get Azure Key Vault secrets
        uses: ./.github/actions/azure-keyvault
        with:
          keyvault-name: ${{ vars.AZURE_KEYVAULT_NAME_DEV }}
          use-managed-identity: 'true'

      - name: Enhanced Deployment
        id: deploy
        uses: ./.github/actions/enhanced-deploy
        with:
          azure-static-web-apps-api-token: ${{ env.AZURE_STATIC_WEB_APPS_API_TOKEN_DEV }}
          environment: development
          version: ${{ needs.detect-changes.outputs.dev-version }}
          enable-health-checks: 'true'
          enable-monitoring: 'true'
          enable-rollback: 'true'
          monitoring-duration: '5'
          slack-webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          teams-webhook-url: ${{ secrets.TEAMS_WEBHOOK_URL }}

      - name: Update Environment Status
        if: always()
        run: |
          STATUS="${{ steps.deploy.outputs.health-check-status }}"
          echo "Development deployment status: $STATUS"
          
          # Update GitHub deployment status
          if [ "$STATUS" = "healthy" ]; then
            echo "üéØ Development environment is healthy"
          else
            echo "‚ö†Ô∏è Development environment needs attention"
          fi

  # Deploy to Staging Environment
  deploy-staging:
    name: üöÄ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [detect-changes, quality-checks, deploy-development]
    if: needs.detect-changes.outputs.should-deploy-staging == 'true' && (success() || needs.deploy-development.result == 'skipped')
    environment: 
      name: staging
      url: https://staging.yourdomain.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Get Azure Key Vault secrets
        uses: ./.github/actions/azure-keyvault
        with:
          keyvault-name: ${{ vars.AZURE_KEYVAULT_NAME_STAGING }}
          use-managed-identity: 'true'

      - name: Enhanced Deployment
        id: deploy
        uses: ./.github/actions/enhanced-deploy
        with:
          azure-static-web-apps-api-token: ${{ env.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}
          environment: staging
          version: ${{ needs.detect-changes.outputs.staging-version }}
          enable-health-checks: 'true'
          enable-monitoring: 'true'
          enable-rollback: 'true'
          monitoring-duration: '10'
          slack-webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          teams-webhook-url: ${{ secrets.TEAMS_WEBHOOK_URL }}

      - name: Run Integration Tests
        run: |
          echo "üß™ Running integration tests against staging..."
          # Add your integration test commands here
          npm run test:integration || echo "Integration tests not configured"

      - name: Performance Testing
        run: |
          echo "‚ö° Running performance tests..."
          # Add Lighthouse or other performance testing
          npx lighthouse https://staging.yourdomain.com --output=json --output-path=lighthouse-staging.json --chrome-flags="--headless --no-sandbox" || echo "Performance tests not configured"

  # Deploy to Pre-Production Environment
  deploy-preprod:
    name: üöÄ Deploy to Pre-Production
    runs-on: ubuntu-latest
    needs: [detect-changes, quality-checks, deploy-staging]
    if: needs.detect-changes.outputs.should-deploy-preprod == 'true' && (success() || needs.deploy-staging.result == 'skipped')
    environment: 
      name: pre-production
      url: https://preprod.yourdomain.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Get Azure Key Vault secrets
        uses: ./.github/actions/azure-keyvault
        with:
          keyvault-name: ${{ vars.AZURE_KEYVAULT_NAME_PROD }}
          use-managed-identity: 'true'

      - name: Enhanced Deployment
        id: deploy
        uses: ./.github/actions/enhanced-deploy
        with:
          azure-static-web-apps-api-token: ${{ env.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}
          environment: pre-production
          version: ${{ needs.detect-changes.outputs.semantic-version }}
          enable-health-checks: 'true'
          enable-monitoring: 'true'
          enable-rollback: 'true'
          monitoring-duration: '15'
          slack-webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          teams-webhook-url: ${{ secrets.TEAMS_WEBHOOK_URL }}

      - name: Security Testing
        run: |
          echo "üîí Running security tests..."
          # Add security testing commands
          echo "Security tests completed"

      - name: Load Testing
        run: |
          echo "üìä Running load tests..."
          # Add load testing commands
          echo "Load tests completed"

  # Deploy to Production Environment (requires manual approval)
  deploy-production:
    name: üöÄ Deploy to Production
    runs-on: ubuntu-latest
    needs: [detect-changes, quality-checks, deploy-preprod]
    if: needs.detect-changes.outputs.should-deploy-prod == 'true' && success()
    environment: 
      name: production
      url: https://yourdomain.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: ./.github/actions/setup-node
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Get Azure Key Vault secrets
        uses: ./.github/actions/azure-keyvault
        with:
          keyvault-name: ${{ vars.AZURE_KEYVAULT_NAME_PROD }}
          use-managed-identity: 'true'

      - name: Enhanced Deployment
        id: deploy
        uses: ./.github/actions/enhanced-deploy
        with:
          azure-static-web-apps-api-token: ${{ env.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}
          environment: production
          version: ${{ needs.detect-changes.outputs.semantic-version }}
          enable-health-checks: 'true'
          enable-monitoring: 'true'
          enable-rollback: 'true'
          monitoring-duration: '30'
          slack-webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          teams-webhook-url: ${{ secrets.TEAMS_WEBHOOK_URL }}

      - name: Post-deployment Validation
        run: |
          echo "‚úÖ Running post-deployment validation..."
          # Add post-deployment validation commands
          curl -f https://yourdomain.com/api/health || echo "Health check failed"

      - name: Create GitHub Release
        if: success()
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.detect-changes.outputs.semantic-version }}
          release_name: Release ${{ needs.detect-changes.outputs.semantic-version }}
          body: |
            üöÄ Production deployment successful
            
            **Version:** ${{ needs.detect-changes.outputs.semantic-version }}
            **Commit:** ${{ github.sha }}
            **Environment:** Production
            
            **Changes:**
            ${{ github.event.head_commit.message }}
          draft: false
          prerelease: false

  # Cleanup and Notifications
  post-deployment:
    name: üìä Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always()
    
    steps:
      - name: Deployment Summary
        run: |
          echo "üìä Deployment Summary"
          echo "===================="
          echo "üè∑Ô∏è Version Tags:"
          echo "  Development: ${{ needs.detect-changes.outputs.dev-version }}"
          echo "  Staging: ${{ needs.detect-changes.outputs.staging-version }}"
          echo "  Pre-Production/Production: ${{ needs.detect-changes.outputs.semantic-version }}"
          echo ""
          echo "üöÄ Deployment Results:"
          echo "  Development: ${{ needs.deploy-development.result }}"
          echo "  Staging: ${{ needs.deploy-staging.result }}"
          echo "  Pre-Production: ${{ needs.deploy-preprod.result }}"
          echo "Production: ${{ needs.deploy-production.result }}"

