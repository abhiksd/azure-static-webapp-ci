name: Shared Frontend CI/CD Pipeline

on:
  workflow_call:
    inputs:
      # Environment configuration (only essential runtime parameter)
      environment:
        description: 'Target environment'
        required: false
        default: 'development'
        type: string
    
    secrets:
      # Required secrets for deployment
      AZURE_STATIC_WEB_APPS_API_TOKEN_DEV:
        description: 'Azure Static Web Apps API token for development'
        required: false
      AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING:
        description: 'Azure Static Web Apps API token for staging'
        required: false
      AZURE_STATIC_WEB_APPS_API_TOKEN_PREPROD:
        description: 'Azure Static Web Apps API token for pre-production'
        required: false
      AZURE_STATIC_WEB_APPS_API_TOKEN_PROD:
        description: 'Azure Static Web Apps API token for production'
        required: false
      
      # Security scanning secrets
      SONAR_TOKEN:
        description: 'SonarCloud token'
        required: false
      CHECKMARX_CLIENT_ID:
        description: 'Checkmarx AST client ID'
        required: false
      CHECKMARX_SECRET:
        description: 'Checkmarx AST client secret'
        required: false
      CHECKMARX_TENANT:
        description: 'Checkmarx tenant'
        required: false
      CHECKMARX_BASE_URI:
        description: 'Checkmarx base URI'
        required: false
    
    outputs:
      # Deployment outputs
      dev-url:
        description: 'Development environment URL'
        value: ${{ jobs.deploy-dev.outputs.deployment-url }}
      staging-url:
        description: 'Staging environment URL'
        value: ${{ jobs.deploy-staging.outputs.deployment-url }}
      preprod-url:
        description: 'Pre-production environment URL'
        value: ${{ jobs.deploy-preprod.outputs.deployment-url }}
      prod-url:
        description: 'Production environment URL'
        value: ${{ jobs.deploy-prod.outputs.deployment-url }}
      
      # Quality metrics
      sonar-status:
        description: 'SonarCloud analysis status'
        value: ${{ jobs.sonar-analysis.outputs.status }}
      sonar-coverage:
        description: 'SonarCloud code coverage'
        value: ${{ jobs.sonar-analysis.outputs.coverage }}
      checkmarx-status:
        description: 'Checkmarx scan status'
        value: ${{ jobs.checkmarx-scan.outputs.status }}
      checkmarx-critical:
        description: 'Checkmarx critical vulnerabilities'
        value: ${{ jobs.checkmarx-scan.outputs.critical-count }}
      checkmarx-high:
        description: 'Checkmarx high vulnerabilities'
        value: ${{ jobs.checkmarx-scan.outputs.high-count }}
      
      # Version info
      version:
        description: 'Deployed version'
        value: ${{ jobs.detect-deployment.outputs.version }}

env:
  # Build configuration (centralized in shared workflow)
  NODE_VERSION: ${{ vars.NODE_VERSION || '18' }}
  APP_LOCATION: ${{ vars.APP_LOCATION || '/' }}
  OUTPUT_LOCATION: ${{ vars.OUTPUT_LOCATION || 'build' }}
  BUILD_COMMAND: ${{ vars.BUILD_COMMAND || 'npm run build' }}
  INSTALL_COMMAND: ${{ vars.INSTALL_COMMAND || 'npm ci' }}
  
  # Security scanning controls (centralized in shared workflow)
  ENABLE_SONAR: ${{ vars.ENABLE_SONAR_SCAN || 'true' }}
  ENABLE_CHECKMARX: ${{ vars.ENABLE_CHECKMARX_SCAN || 'true' }}
  
  # SonarQube/SonarCloud configuration (centralized)
  SONAR_HOST_URL: ${{ vars.SONAR_HOST_URL || 'https://sonarcloud.io' }}
  SONAR_SKIP_SSL_VERIFICATION: ${{ vars.SONAR_SKIP_SSL_VERIFICATION || 'false' }}
  
  # Quality gate thresholds (centralized in shared workflow)
  MIN_CODE_COVERAGE: ${{ vars.MIN_CODE_COVERAGE || '75' }}
  MAX_CRITICAL_VULNERABILITIES: ${{ vars.MAX_CRITICAL_VULNERABILITIES || '0' }}
  MAX_HIGH_VULNERABILITIES: ${{ vars.MAX_HIGH_VULNERABILITIES || '5' }}
  MAX_BLOCKER_ISSUES: ${{ vars.MAX_BLOCKER_ISSUES || '0' }}
  MAX_CRITICAL_ISSUES: ${{ vars.MAX_CRITICAL_ISSUES || '0' }}
  
  # Checkmarx configuration (centralized)
  CHECKMARX_SCAN_TYPES: ${{ vars.CHECKMARX_SCAN_TYPES || 'sast,sca' }}
  CHECKMARX_PRESET: ${{ vars.CHECKMARX_PRESET || 'Checkmarx Default' }}
  
  # Deployment controls (centralized)
  SKIP_DEPLOYMENT: ${{ vars.SKIP_DEPLOYMENT || 'false' }}
  FORCE_VERSION: ${{ vars.FORCE_VERSION || '' }}
  
  # Common Azure Static Web Apps deployment parameters
  AZURE_REPO_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  AZURE_ACTION: "upload"
  AZURE_APP_LOCATION: ${{ vars.APP_LOCATION || '/' }}
  AZURE_OUTPUT_LOCATION: ${{ vars.OUTPUT_LOCATION || 'build' }}

jobs:
  detect-deployment:
    runs-on: ubuntu-latest
    outputs:
      should-deploy-dev: ${{ steps.deployment-logic.outputs.deploy-dev }}
      should-deploy-staging: ${{ steps.deployment-logic.outputs.deploy-staging }}
      should-deploy-preprod: ${{ steps.deployment-logic.outputs.deploy-preprod }}
      should-deploy-prod: ${{ steps.deployment-logic.outputs.deploy-prod }}
      version: ${{ steps.version.outputs.version }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Version
        id: version
        run: |
                  if [ -n "${{ env.FORCE_VERSION }}" ]; then
          VERSION="${{ env.FORCE_VERSION }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION="$(date +'%Y.%m.%d')-${GITHUB_SHA::8}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

      - name: Determine Deployment Strategy
        id: deployment-logic
        run: |
          BRANCH="${{ github.ref_name }}"
          ENVIRONMENT="${{ inputs.environment }}"
          
          # Default deployment logic
          DEPLOY_DEV="false"
          DEPLOY_STAGING="false"
          DEPLOY_PREPROD="false"
          DEPLOY_PROD="false"
          
          if [ "${{ env.SKIP_DEPLOYMENT }}" = "true" ]; then
            echo "Deployment skipped by input"
          elif [ -n "$ENVIRONMENT" ] && [ "$ENVIRONMENT" != "development" ]; then
            # Manual workflow dispatch with specific environment
            case $ENVIRONMENT in
              staging) DEPLOY_STAGING="true" ;;
              pre-production) DEPLOY_PREPROD="true" ;;
              production) DEPLOY_PROD="true" ;;
              *) DEPLOY_DEV="true" ;;
            esac
          else
            # Auto deployment based on branch
            case $BRANCH in
              main|master) DEPLOY_PROD="true" ;;
              develop|development) DEPLOY_DEV="true" ;;
              staging) DEPLOY_STAGING="true" ;;
              preprod|pre-production) DEPLOY_PREPROD="true" ;;
              *) DEPLOY_DEV="true" ;;
            esac
          fi
          
          echo "deploy-dev=$DEPLOY_DEV" >> $GITHUB_OUTPUT
          echo "deploy-staging=$DEPLOY_STAGING" >> $GITHUB_OUTPUT
          echo "deploy-preprod=$DEPLOY_PREPROD" >> $GITHUB_OUTPUT
          echo "deploy-prod=$DEPLOY_PROD" >> $GITHUB_OUTPUT

  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install Dependencies and Build
        run: |
          ${{ env.INSTALL_COMMAND }}
          ${{ env.BUILD_COMMAND }}
          npm test 2>/dev/null || echo "No tests found or test command not available"

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: ${{ env.OUTPUT_LOCATION }}/
          retention-days: 7

      - name: Upload Versioned Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ github.sha }}
          path: ${{ env.OUTPUT_LOCATION }}/
          retention-days: 30

  sonar-analysis:
    runs-on: ubuntu-latest
    needs: [build-and-test]
    if: always() && (env.ENABLE_SONAR != 'false')
    outputs:
      status: ${{ steps.sonar-scan.outputs.status }}
      coverage: ${{ steps.sonar-scan.outputs.coverage }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install Dependencies
        run: ${{ env.INSTALL_COMMAND }}

      - name: SonarCloud Analysis
        id: sonar-scan
        uses: ./.github/actions/sonar-analysis
        with:
          enabled: ${{ env.ENABLE_SONAR }}
          sonar-token: ${{ secrets.SONAR_TOKEN }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          organization: ${{ vars.SONAR_ORGANIZATION }}
          sonar-host-url: ${{ env.SONAR_HOST_URL }}
          skip-ssl-verification: ${{ env.SONAR_SKIP_SSL_VERIFICATION }}
          min-code-coverage: ${{ env.MIN_CODE_COVERAGE }}
          max-blocker-issues: ${{ env.MAX_BLOCKER_ISSUES }}
          max-critical-issues: ${{ env.MAX_CRITICAL_ISSUES }}

  checkmarx-scan:
    runs-on: ubuntu-latest
    needs: [build-and-test]
    if: always() && (env.ENABLE_CHECKMARX != 'false')
    outputs:
      status: ${{ steps.checkmarx-security.outputs.status }}
      critical-count: ${{ steps.checkmarx-security.outputs.critical-count }}
      high-count: ${{ steps.checkmarx-security.outputs.high-count }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install Dependencies
        run: ${{ env.INSTALL_COMMAND }}

      - name: Checkmarx Security Scan
        id: checkmarx-security
        uses: ./.github/actions/checkmarx-scan
        with:
          enabled: ${{ env.ENABLE_CHECKMARX }}
          base-uri: ${{ secrets.CHECKMARX_BASE_URI || 'https://ast.checkmarx.net' }}
          checkmarx-client-id: ${{ secrets.CHECKMARX_CLIENT_ID }}
          checkmarx-secret: ${{ secrets.CHECKMARX_SECRET }}
          tenant: ${{ secrets.CHECKMARX_TENANT }}
          scan-types: ${{ env.CHECKMARX_SCAN_TYPES }}
          max-critical: ${{ env.MAX_CRITICAL_VULNERABILITIES }}
          max-high: ${{ env.MAX_HIGH_VULNERABILITIES }}
          preset: ${{ env.CHECKMARX_PRESET }}

  deploy-dev:
    if: always() && needs.detect-deployment.outputs.should-deploy-dev == 'true' && env.SKIP_DEPLOYMENT != 'true'
    runs-on: ubuntu-latest
    needs: [detect-deployment, build-and-test, sonar-analysis, checkmarx-scan]
    environment: development
    outputs:
      deployment-url: ${{ steps.deploy.outputs.static-web-app-url }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: ${{ env.OUTPUT_LOCATION }}/

      - name: Deploy to Development
        id: deploy
        uses: ./.github/actions/deploy-static-app
        with:
          azure-static-web-apps-api-token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_DEV }}
          environment: 'development'
          version: ${{ needs.detect-deployment.outputs.version }}
          app-location: ${{ env.APP_LOCATION }}
          output-location: ${{ env.OUTPUT_LOCATION }}
          skip-build: 'true'

  deploy-staging:
    if: always() && needs.detect-deployment.outputs.should-deploy-staging == 'true' && env.SKIP_DEPLOYMENT != 'true'
    runs-on: ubuntu-latest
    needs: [detect-deployment, build-and-test, sonar-analysis, checkmarx-scan]
    environment: staging
    outputs:
      deployment-url: ${{ steps.deploy.outputs.static-web-app-url }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: ${{ env.OUTPUT_LOCATION }}/

      - name: Deploy to Staging
        id: deploy
        uses: ./.github/actions/deploy-static-app
        with:
          azure-static-web-apps-api-token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}
          environment: 'staging'
          version: ${{ needs.detect-deployment.outputs.version }}
          app-location: ${{ env.APP_LOCATION }}
          output-location: ${{ env.OUTPUT_LOCATION }}
          skip-build: 'true'

  deploy-preprod:
    if: always() && needs.detect-deployment.outputs.should-deploy-preprod == 'true' && env.SKIP_DEPLOYMENT != 'true'
    runs-on: ubuntu-latest
    needs: [detect-deployment, build-and-test, sonar-analysis, checkmarx-scan]
    environment: pre-production
    outputs:
      deployment-url: ${{ steps.deploy.outputs.static-web-app-url }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: ${{ env.OUTPUT_LOCATION }}/

      - name: Deploy to Pre-Production
        id: deploy
        uses: ./.github/actions/deploy-static-app
        with:
          azure-static-web-apps-api-token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_PREPROD }}
          environment: 'pre-production'
          version: ${{ needs.detect-deployment.outputs.version }}
          app-location: ${{ env.APP_LOCATION }}
          output-location: ${{ env.OUTPUT_LOCATION }}
          skip-build: 'true'

  deploy-prod:
    if: always() && needs.detect-deployment.outputs.should-deploy-prod == 'true' && env.SKIP_DEPLOYMENT != 'true'
    runs-on: ubuntu-latest
    needs: [detect-deployment, build-and-test, sonar-analysis, checkmarx-scan]
    environment: production
    outputs:
      deployment-url: ${{ steps.deploy.outputs.static-web-app-url }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: ${{ env.OUTPUT_LOCATION }}/

      - name: Deploy to Production
        id: deploy
        uses: ./.github/actions/deploy-static-app
        with:
          azure-static-web-apps-api-token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}
          environment: 'production'
          version: ${{ needs.detect-deployment.outputs.version }}
          app-location: ${{ env.APP_LOCATION }}
          output-location: ${{ env.OUTPUT_LOCATION }}
          skip-build: 'true'

  # Rollback jobs for preprod and production
  rollback-preprod:
    if: always() && (failure() || github.event.inputs.rollback_preprod == 'true') && needs.deploy-preprod.result == 'failure'
    runs-on: ubuntu-latest
    needs: [detect-deployment, deploy-preprod]
    environment: pre-production
    outputs:
      rollback-status: ${{ steps.rollback.outputs.status }}
      previous-version: ${{ steps.rollback.outputs.previous-version }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Get Previous Successful Version
        id: get-previous-version
        run: |
          # Get the last successful deployment from Azure Static Web Apps
          # This would typically fetch from deployment history or artifact store
          PREVIOUS_VERSION=$(curl -s "https://api.github.com/repos/${{ github.repository }}/deployments" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" | \
            jq -r '.[] | select(.environment == "pre-production" and .statuses_url != null) | .ref' | head -n 2 | tail -n 1)
          
          if [ -z "$PREVIOUS_VERSION" ] || [ "$PREVIOUS_VERSION" = "null" ]; then
            echo "No previous version found for rollback"
            echo "previous-version=none" >> $GITHUB_OUTPUT
          else
            echo "Previous version found: $PREVIOUS_VERSION"
            echo "previous-version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Download Previous Build Artifacts
        if: steps.get-previous-version.outputs.previous-version != 'none'
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ steps.get-previous-version.outputs.previous-version }}
          path: ${{ env.OUTPUT_LOCATION }}/
        continue-on-error: true

      - name: Perform Rollback to Pre-Production
        if: steps.get-previous-version.outputs.previous-version != 'none'
        id: rollback
        uses: ./.github/actions/deploy-static-app
        with:
          azure-static-web-apps-api-token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_PREPROD }}
          environment: 'pre-production'
          version: ${{ steps.get-previous-version.outputs.previous-version }}
          app-location: ${{ env.APP_LOCATION }}
          output-location: ${{ env.OUTPUT_LOCATION }}
          skip-build: 'true'
        continue-on-error: true

      - name: Verify Rollback Success
        if: steps.get-previous-version.outputs.previous-version != 'none'
        run: |
          if [ "${{ steps.rollback.outcome }}" = "success" ]; then
            echo "Rollback to pre-production successful"
            echo "status=success" >> $GITHUB_OUTPUT
            echo "previous-version=${{ steps.get-previous-version.outputs.previous-version }}" >> $GITHUB_OUTPUT
          else
            echo "Rollback to pre-production failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Notify Rollback Failure
        if: steps.get-previous-version.outputs.previous-version == 'none' || steps.rollback.outcome == 'failure'
        run: |
          echo "Pre-production rollback failed - manual intervention required"
          echo "status=manual-required" >> $GITHUB_OUTPUT

  rollback-prod:
    if: always() && (failure() || github.event.inputs.rollback_prod == 'true') && needs.deploy-prod.result == 'failure'
    runs-on: ubuntu-latest
    needs: [detect-deployment, deploy-prod]
    environment: production
    outputs:
      rollback-status: ${{ steps.rollback.outputs.status }}
      previous-version: ${{ steps.rollback.outputs.previous-version }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Get Previous Successful Version
        id: get-previous-version
        run: |
          # Get the last successful deployment from Azure Static Web Apps
          PREVIOUS_VERSION=$(curl -s "https://api.github.com/repos/${{ github.repository }}/deployments" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" | \
            jq -r '.[] | select(.environment == "production" and .statuses_url != null) | .ref' | head -n 2 | tail -n 1)
          
          if [ -z "$PREVIOUS_VERSION" ] || [ "$PREVIOUS_VERSION" = "null" ]; then
            echo "No previous version found for rollback"
            echo "previous-version=none" >> $GITHUB_OUTPUT
          else
            echo "Previous version found: $PREVIOUS_VERSION"
            echo "previous-version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Download Previous Build Artifacts
        if: steps.get-previous-version.outputs.previous-version != 'none'
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-${{ steps.get-previous-version.outputs.previous-version }}
          path: ${{ env.OUTPUT_LOCATION }}/
        continue-on-error: true

      - name: Perform Rollback to Production
        if: steps.get-previous-version.outputs.previous-version != 'none'
        id: rollback
        uses: ./.github/actions/deploy-static-app
        with:
          azure-static-web-apps-api-token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}
          environment: 'production'
          version: ${{ steps.get-previous-version.outputs.previous-version }}
          app-location: ${{ env.APP_LOCATION }}
          output-location: ${{ env.OUTPUT_LOCATION }}
          skip-build: 'true'
        continue-on-error: true

      - name: Verify Rollback Success
        if: steps.get-previous-version.outputs.previous-version != 'none'
        run: |
          if [ "${{ steps.rollback.outcome }}" = "success" ]; then
            echo "Rollback to production successful"
            echo "status=success" >> $GITHUB_OUTPUT
            echo "previous-version=${{ steps.get-previous-version.outputs.previous-version }}" >> $GITHUB_OUTPUT
          else
            echo "Rollback to production failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Notify Rollback Failure
        if: steps.get-previous-version.outputs.previous-version == 'none' || steps.rollback.outcome == 'failure'
        run: |
          echo "Production rollback failed - manual intervention required"
          echo "status=manual-required" >> $GITHUB_OUTPUT

  deployment-summary:
    if: always() && env.SKIP_DEPLOYMENT != 'true'
    runs-on: ubuntu-latest
    needs: [detect-deployment, sonar-analysis, checkmarx-scan, deploy-dev, deploy-staging, deploy-preprod, deploy-prod, rollback-preprod, rollback-prod]
    
    steps:
      - name: Deployment Summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "Version: ${{ needs.detect-deployment.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.deploy-dev.result }}" = "success" ]; then
            echo "**Development**: ${{ needs.deploy-dev.outputs.deployment-url }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ needs.deploy-staging.result }}" = "success" ]; then
            echo "**Staging**: ${{ needs.deploy-staging.outputs.deployment-url }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ needs.deploy-preprod.result }}" = "success" ]; then
            echo "**Pre-Production**: ${{ needs.deploy-preprod.outputs.deployment-url }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ needs.deploy-prod.result }}" = "success" ]; then
            echo "**Production**: ${{ needs.deploy-prod.outputs.deployment-url }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Security Scan Results" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.sonar-analysis.result }}" = "success" ]; then
            echo "**SonarCloud**: ${{ needs.sonar-analysis.outputs.status }} (Coverage: ${{ needs.sonar-analysis.outputs.coverage }}%)" >> $GITHUB_STEP_SUMMARY
          else
            echo "**SonarCloud**: ${{ needs.sonar-analysis.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ needs.checkmarx-scan.result }}" = "success" ]; then
            echo "**Checkmarx**: ${{ needs.checkmarx-scan.outputs.status }} (Critical: ${{ needs.checkmarx-scan.outputs.critical-count }}, High: ${{ needs.checkmarx-scan.outputs.high-count }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Checkmarx**: ${{ needs.checkmarx-scan.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Add rollback information if any rollbacks occurred
          if [ "${{ needs.rollback-preprod.result }}" = "success" ] || [ "${{ needs.rollback-prod.result }}" = "success" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "##Rollback Information" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ needs.rollback-preprod.result }}" = "success" ]; then
              echo "**Pre-Production Rollback**: Completed successfully" >> $GITHUB_STEP_SUMMARY
              echo "**Rollback Version**: ${{ needs.rollback-preprod.outputs.previous-version }}" >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ "${{ needs.rollback-prod.result }}" = "success" ]; then
              echo "**Production Rollback**: Completed successfully" >> $GITHUB_STEP_SUMMARY
              echo "**Rollback Version**: ${{ needs.rollback-prod.outputs.previous-version }}" >> $GITHUB_STEP_SUMMARY
            fi
          elif [ "${{ needs.rollback-preprod.result }}" = "failure" ] || [ "${{ needs.rollback-prod.result }}" = "failure" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Rollback Issues" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ needs.rollback-preprod.result }}" = "failure" ]; then
              echo "**Pre-Production Rollback**: Failed - manual intervention required" >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ "${{ needs.rollback-prod.result }}" = "failure" ]; then
              echo "**Production Rollback**: Failed - manual intervention required" >> $GITHUB_STEP_SUMMARY
            fi
          fi