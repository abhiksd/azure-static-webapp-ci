name: 'Azure Key Vault'
description: 'Retrieve secrets from Azure Key Vault with Managed Identity'

inputs:
  keyvault-name:
    description: 'Name of the Azure Key Vault'
    required: true
  use-managed-identity:
    description: 'Use managed identity for authentication (default: true)'
    required: false
    default: 'true'
  secrets-list:
    description: 'Comma-separated list of secrets to retrieve'
    required: false
    default: ''
  set-env-vars:
    description: 'Set retrieved secrets as environment variables'
    required: false
    default: 'true'
  output-format:
    description: 'Output format for secrets (env|json|mask)'
    required: false
    default: 'env'

outputs:
  secrets-retrieved:
    description: 'Number of secrets successfully retrieved'
    value: ${{ steps.get-secrets.outputs.secrets-count }}
  secrets-json:
    description: 'Retrieved secrets in JSON format'
    value: ${{ steps.get-secrets.outputs.secrets-json }}

runs:
  using: 'composite'
  steps:
    - name: Verify Azure CLI Authentication
      shell: bash
      run: |
        echo "Verifying Azure CLI authentication with managed identity..."
        
        # Check if Azure CLI is authenticated
        if ! az account show >/dev/null 2>&1; then
          echo "Azure CLI is not authenticated"
          echo "Please ensure the GitHub runner has managed identity configured"
          exit 1
        fi
        
        echo "Azure CLI authentication verified"
        
        # Show current subscription (masked for security)
        SUBSCRIPTION_ID=$(az account show --query id -o tsv)
        echo "Current subscription: ${SUBSCRIPTION_ID:0:8}****"

    - name: Get Key Vault Secrets
      id: get-secrets
      shell: bash
      run: |
        KEYVAULT_NAME="${{ inputs.keyvault-name }}"
        SECRETS_LIST="${{ inputs.secrets-list }}"
        SET_ENV_VARS="${{ inputs.set-env-vars }}"
        OUTPUT_FORMAT="${{ inputs.output-format }}"
        
        echo "Retrieving secrets from Key Vault: $KEYVAULT_NAME"
        
        # Verify Key Vault access
        if ! az keyvault show --name "$KEYVAULT_NAME" >/dev/null 2>&1; then
          echo "Cannot access Key Vault: $KEYVAULT_NAME"
          echo "Please verify:"
          echo "1. Key Vault exists"
          echo "2. Managed identity has appropriate permissions"
          echo "3. Key Vault name is correct"
          exit 1
        fi
        
        echo "Key Vault access verified"
        
        # If no specific secrets list provided, get common application secrets
        if [ -z "$SECRETS_LIST" ]; then
          echo "No specific secrets list provided, discovering available secrets..."
          
          # Get all available secrets (limit to prevent overwhelming output)
          AVAILABLE_SECRETS=$(az keyvault secret list --vault-name "$KEYVAULT_NAME" --query '[0:20].name' -o tsv 2>/dev/null || echo "")
          
          if [ -n "$AVAILABLE_SECRETS" ]; then
            # Use first 10 secrets or common patterns
            SECRETS_LIST=$(echo "$AVAILABLE_SECRETS" | head -10 | tr '\n' ',' | sed 's/,$//')
            echo "Found secrets: $SECRETS_LIST"
          else
            # Fallback to common secret names
            SECRETS_LIST="app-config,database-connection,api-keys,jwt-secret,storage-connection"
            echo "Using default secret patterns: $SECRETS_LIST"
          fi
        fi
        
        # Convert comma-separated list to array
        IFS=',' read -ra SECRETS_ARRAY <<< "$SECRETS_LIST"
        
        SECRETS_COUNT=0
        SECRETS_JSON="{"
        FAILED_SECRETS=""
        
        echo "Processing ${#SECRETS_ARRAY[@]} secrets..."
        
        for SECRET_NAME in "${SECRETS_ARRAY[@]}"; do
          # Trim whitespace
          SECRET_NAME=$(echo "$SECRET_NAME" | xargs)
          
          if [ -z "$SECRET_NAME" ]; then
            continue
          fi
          
          echo "Retrieving secret: $SECRET_NAME"
          
          # Retrieve secret value with error handling
          SECRET_VALUE=$(az keyvault secret show \
            --vault-name "$KEYVAULT_NAME" \
            --name "$SECRET_NAME" \
            --query value \
            -o tsv 2>/dev/null)
          
          if [ $? -eq 0 ] && [ -n "$SECRET_VALUE" ]; then
            echo "Successfully retrieved: $SECRET_NAME"
            
            # Set as environment variable if requested
            if [ "$SET_ENV_VARS" = "true" ]; then
              # Convert secret name to valid environment variable name
              ENV_VAR_NAME=$(echo "$SECRET_NAME" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
              
              case "$OUTPUT_FORMAT" in
                "mask")
                  echo "::add-mask::$SECRET_VALUE"
                  echo "$ENV_VAR_NAME=$SECRET_VALUE" >> $GITHUB_ENV
                  echo "Set masked environment variable: $ENV_VAR_NAME"
                  ;;
                "env")
                  echo "$ENV_VAR_NAME=$SECRET_VALUE" >> $GITHUB_ENV
                  echo "Set environment variable: $ENV_VAR_NAME"
                  ;;
              esac
            fi
            
            # Add to JSON output (mask the value in logs)
            if [ "$SECRETS_COUNT" -gt 0 ]; then
              SECRETS_JSON+=","
            fi
            SECRETS_JSON+="\"$SECRET_NAME\":\"***\""
            
            SECRETS_COUNT=$((SECRETS_COUNT + 1))
          else
            echo "Failed to retrieve secret: $SECRET_NAME"
            FAILED_SECRETS="$FAILED_SECRETS $SECRET_NAME"
          fi
        done
        
        SECRETS_JSON+="}"
        
        echo "Summary:"
        echo " - Successfully retrieved: $SECRETS_COUNT secrets"
        echo " - Failed: $(echo $FAILED_SECRETS | wc -w) secrets"
        
        if [ -n "$FAILED_SECRETS" ]; then
          echo "Failed secrets:$FAILED_SECRETS"
          echo "Please verify these secrets exist and the managed identity has read permissions"
        fi
        
        # Set outputs
        echo "secrets-count=$SECRETS_COUNT" >> $GITHUB_OUTPUT
        echo "secrets-json=$SECRETS_JSON" >> $GITHUB_OUTPUT
        
        if [ "$SECRETS_COUNT" -eq 0 ]; then
          echo "No secrets were retrieved successfully"
          exit 1
        fi
        
        echo "Key Vault secrets retrieval completed"

    - name: Verify Environment Variables
      shell: bash
      if: inputs.set-env-vars == 'true'
      run: |
        echo "Verifying environment variables are set..."
        
        # Check for common environment variables
        ENV_VARS_SET=0
        
        for var in $(env | grep -E '^[A-Z_]+=' | cut -d= -f1); do
          if [[ "$var" =~ ^[A-Z_]+$ ]] && [ ${#var} -gt 3 ]; then
            ENV_VARS_SET=$((ENV_VARS_SET + 1))
          fi
        done
        
        echo "Environment variables set: $ENV_VARS_SET"
        echo "Environment verification completed"

    - name: Security Cleanup
      shell: bash
      if: always()
      run: |
        echo "Performing security cleanup..."
        
        # Clear any temporary files that might contain secrets
        find /tmp -name "*azure*" -type f -delete 2>/dev/null || true
        find /tmp -name "*secret*" -type f -delete 2>/dev/null || true
        
        # Clear Azure CLI cache if it contains sensitive data
        az account clear 2>/dev/null || true
        
        echo "Security cleanup completed"